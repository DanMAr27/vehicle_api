# app/services/maintenances/alerts_service.rb
module Maintenances
  class AlertsService
    attr_reader :maintenances, :results

    def initialize(vehicle_id: nil, alert_type: nil)
      @vehicle_id = vehicle_id
      @alert_type = alert_type
      @results = []
    end

    def call
      load_maintenances
      build_results
      filter_by_alert_type if @alert_type.present?

      {
        success: true,
        total: @maintenances.count,
        with_issues: @results.count { |r| r[:has_issues] },
        maintenances: @results
      }
    end

    private

    def load_maintenances
      @maintenances = Maintenance.kept.includes(:vehicle_km)
      @maintenances = @maintenances.where(vehicle_id: @vehicle_id) if @vehicle_id
    end

    def build_results
      @results = @maintenances.map do |maintenance|
        {
          maintenance_id: maintenance.id,
          vehicle_id: maintenance.vehicle_id,
          maintenance_date: maintenance.maintenance_date,
          km_status: maintenance.km_status,
          is_conflictive: maintenance.km_conflictive?,
          is_desynchronized: maintenance.km_desynchronized?,
          has_issues: has_issues?(maintenance)
        }
      end
    end

    def has_issues?(maintenance)
      maintenance.km_status != "activo" ||
        maintenance.km_desynchronized? ||
        maintenance.km_conflictive?
    end

    def filter_by_alert_type
      @results = @results.select do |result|
        case @alert_type
        when "eliminado"
          result[:km_status] == "eliminado"
        when "sin_registro"
          result[:km_status] == "sin_registro"
        when "desincronizado"
          result[:is_desynchronized]
        when "conflictivo"
          result[:is_conflictive]
        else
          true
        end
      end
    end
  end
end
# app/services/maintenances/create_service.rb
module Maintenances
  class CreateService
    attr_reader :errors, :maintenance, :vehicle_km, :warnings

    def initialize(vehicle_id:, params:)
      @vehicle_id = vehicle_id
      @params = params
      @errors = []
      @warnings = []
      @maintenance = nil
      @vehicle_km = nil
    end

    def call
      validate_vehicle
      return failure unless @errors.empty?

      ActiveRecord::Base.transaction do
        create_maintenance
        create_km_record_if_requested
        success
      end
    rescue ActiveRecord::RecordInvalid => e
      @errors << e.message
      failure
    rescue StandardError => e
      @errors << e.message
      failure
    end

    private

    def validate_vehicle
      @vehicle = Vehicle.kept.find_by(id: @vehicle_id)
      @errors << "Vehículo no encontrado" unless @vehicle
    end

    def create_maintenance
      @maintenance = Maintenance.create!(
        vehicle: @vehicle,
        company: @vehicle.company,
        maintenance_date: @params[:maintenance_date],
        register_km: @params[:register_km],
        amount: @params[:amount],
        description: @params[:description]
      )
    end

    def create_km_record_if_requested
      return unless @params[:create_km_record]

      # Pasar los campos polimórficos correctamente
      km_result = VehicleKms::CreateService.new(
        vehicle_id: @vehicle_id,
        params: {
          input_date: @params[:maintenance_date],
          km_reported: @params[:register_km],
          source_record_type: "Maintenance",  # ✅ Tipo del modelo
          source_record_id: @maintenance.id   # ✅ ID del registro
        }
      ).call

      if km_result[:success]
        @vehicle_km = km_result[:vehicle_km]

        # Vincular el maintenance con el vehicle_km (relación fuerte)
        @maintenance.update!(vehicle_km_id: @vehicle_km.id)

        if km_result[:needs_review]
          @warnings << "El registro de KM fue marcado como conflictivo y requiere revisión"
        end
      else
        @errors.concat(km_result[:errors])
        raise ActiveRecord::Rollback
      end
    end

    def success
      {
        success: true,
        maintenance: @maintenance,
        vehicle_km: @vehicle_km,
        warnings: @warnings
      }
    end

    def failure
      {
        success: false,
        errors: @errors,
        maintenance: @maintenance
      }
    end
  end
end
# app/services/maintenances/delete_service.rb
module Maintenances
  class DeleteService
    attr_reader :errors, :maintenance, :notes

    def initialize(maintenance_id:, delete_km_record: true) # ✅ Por defecto TRUE
      @maintenance_id = maintenance_id
      @delete_km_record = delete_km_record
      @errors = []
      @notes = []
    end

    def call
      validate_maintenance
      return failure unless @errors.empty?

      ActiveRecord::Base.transaction do
        delete_km_record_if_needed
        soft_delete_maintenance
        success
      end
    rescue StandardError => e
      @errors << e.message
      failure
    end

    private

    def validate_maintenance
      @maintenance = Maintenance.kept.find_by(id: @maintenance_id)
      @errors << "Mantenimiento no encontrado" unless @maintenance
    end

    def delete_km_record_if_needed
      return unless @maintenance.vehicle_km.present?
      return unless @maintenance.vehicle_km.kept? # Solo si no está ya descartado

      # Por defecto eliminamos el KM asociado (comportamiento en cascada)
      if @delete_km_record
        km_result = VehicleKms::DeleteService.new(
          vehicle_km_id: @maintenance.vehicle_km.id
        ).call

        if km_result[:success]
          @notes << "Registro de KM eliminado automáticamente (cascada)"
        else
          # Si falla, registramos pero no detenemos el proceso
          @notes << "Advertencia: No se pudo eliminar el KM: #{km_result[:errors].join(', ')}"
        end
      else
        # Desvincular sin eliminar
        @maintenance.update!(vehicle_km_id: nil)
        @notes << "Registro de KM desvinculado pero no eliminado"
      end
    end

    def soft_delete_maintenance
      @maintenance.discard
      @notes << "Mantenimiento eliminado correctamente"
    end

    def success
      {
        success: true,
        maintenance: @maintenance,
        message: @notes.first,
        notes: @notes
      }
    end

    def failure
      {
        success: false,
        errors: @errors
      }
    end
  end
end
# app/services/maintenances/sync_km_service.rb
module Maintenances
  class SyncKmService
    attr_reader :errors, :maintenance, :message

    def initialize(maintenance_id:)
      @maintenance_id = maintenance_id
      @errors = []
      @message = ""
    end

    def call
      validate_maintenance
      return failure unless @errors.empty?

      ActiveRecord::Base.transaction do
        if needs_km_creation_or_restoration?
          handle_km_record
        elsif needs_km_update?
          update_km_record
        else
          @message = "El KM ya está sincronizado"
        end

        success
      end
    rescue StandardError => e
      @errors << e.message
      failure
    end

    private

    def validate_maintenance
      @maintenance = Maintenance.kept.find_by(id: @maintenance_id)
      @errors << "Mantenimiento no encontrado" unless @maintenance
    end

    def needs_km_creation_or_restoration?
      # Sin registro o registro descartado
      @maintenance.vehicle_km.nil? || @maintenance.vehicle_km.discarded?
    end

    def needs_km_update?
      @maintenance.vehicle_km.present? &&
        !@maintenance.vehicle_km.discarded? &&
        @maintenance.km_desynchronized?
    end

    def handle_km_record
      existing_discarded = find_existing_discarded_km

      if existing_discarded
        restore_km_record(existing_discarded)
      else
        create_new_km_record
      end
    end

    def find_existing_discarded_km
      # Buscar si existe un registro descartado con los mismos datos
      VehicleKm.discarded
        .where(
          vehicle_id: @maintenance.vehicle_id,
          source_record_type: "Maintenance",
          source_record_id: @maintenance.id
        )
        .order(discarded_at: :desc)
        .first
    end

    def restore_km_record(km_record)
      # Actualizar datos por si cambiaron
      km_record.update!(
        input_date: @maintenance.maintenance_date,
        km_reported: @maintenance.register_km,
        km_normalized: @maintenance.register_km,
        discarded_at: nil
      )

      # Vincular al mantenimiento
      @maintenance.update!(vehicle_km_id: km_record.id)

      # Re-validar conflictos después de restaurar
      revalidate_after_restoration(km_record)

      @message = "Registro de KM restaurado y actualizado"
    end

    def create_new_km_record
      km_result = VehicleKms::CreateService.new(
        vehicle_id: @maintenance.vehicle_id,
        params: {
          input_date: @maintenance.maintenance_date,
          km_reported: @maintenance.register_km,
          source_record_type: "Maintenance",
          source_record_id: @maintenance.id
        }
      ).call

      if km_result[:success]
        @maintenance.update!(vehicle_km_id: km_result[:vehicle_km].id)
        @message = "Registro de KM creado y vinculado"
      else
        @errors.concat(km_result[:errors])
        raise ActiveRecord::Rollback
      end
    end

    def update_km_record
      km_result = VehicleKms::UpdateService.new(
        vehicle_km_id: @maintenance.vehicle_km.id,
        params: {
          input_date: @maintenance.maintenance_date,
          km_reported: @maintenance.register_km,
          km_normalized: @maintenance.register_km
        }
      ).call

      if km_result[:success]
        @message = "Registro de KM actualizado"
      else
        @errors.concat(km_result[:errors])
        raise ActiveRecord::Rollback
      end
    end

    def revalidate_after_restoration(km_record)
      # Ejecutar validación de conflictos
      detector = VehicleKms::ConflictDetectorService.new(km_record)
      result = detector.call

      return unless result[:has_conflict]

      # Procesar conflictos detectados
      result[:conflictive_records].each do |conflict_info|
        record = VehicleKm.find(conflict_info[:record_id])

        corrector = VehicleKms::KmCorrectionService.new(record)
        correction_result = corrector.call

        if correction_result[:success]
          record.update!(
            km_normalized: correction_result[:corrected_km],
            status: "corregido",
            conflict_reasons_list: conflict_info[:reasons],
            correction_notes: correction_result[:notes]
          )
        else
          record.update!(
            km_normalized: record.km_reported,
            status: "conflictivo",
            conflict_reasons_list: conflict_info[:reasons],
            correction_notes: correction_result[:notes]
          )
        end
      end
    end

    def success
      {
        success: true,
        maintenance: @maintenance.reload,
        message: @message
      }
    end

    def failure
      {
        success: false,
        errors: @errors
      }
    end
  end
end
# app/services/maintenances/update_service.rb
module Maintenances
  class UpdateService
    attr_reader :errors, :maintenance, :warnings

    def initialize(maintenance_id:, params:)
      @maintenance_id = maintenance_id
      @params = params
      @errors = []
      @warnings = []
    end

    def call
      validate_maintenance
      return failure unless @errors.empty?

      ActiveRecord::Base.transaction do
        update_maintenance
        update_km_record_if_requested
        success
      end
    rescue ActiveRecord::RecordInvalid => e
      @errors << e.message
      failure
    rescue StandardError => e
      @errors << e.message
      failure
    end

    private

    def validate_maintenance
      @maintenance = Maintenance.kept.find_by(id: @maintenance_id)
      @errors << "Mantenimiento no encontrado" unless @maintenance
    end

    def update_maintenance
      # Actualizar primero el maintenance para tener los nuevos valores
      update_params = @params.except(:update_km_record, :create_km_record)
      @maintenance.update!(update_params)
    end

    def update_km_record_if_requested
      # Permitir crear KM si no existe
      if @params[:create_km_record] && @maintenance.vehicle_km.nil?
        create_km_record
        return
      end

      # Actualizar KM existente
      return unless @params[:update_km_record]
      return unless @maintenance.vehicle_km.present?
      return unless @params[:register_km].present?

      km_result = VehicleKms::UpdateService.new(
        vehicle_km_id: @maintenance.vehicle_km.id,
        params: {
          km_reported: @params[:register_km],
          km_normalized: @params[:register_km]
        }
      ).call

      unless km_result[:success]
        @errors.concat(km_result[:errors])
        raise ActiveRecord::Rollback
      end

      if km_result[:vehicle_km]&.needs_review?
        @warnings << "El registro de KM actualizado está en conflicto"
      end
    end

    def create_km_record
      # Crear KM desde update si no existe
      km_result = VehicleKms::CreateService.new(
        vehicle_id: @maintenance.vehicle_id,
        params: {
          input_date: @maintenance.maintenance_date,
          km_reported: @maintenance.register_km,
          source_record_type: "Maintenance",
          source_record_id: @maintenance.id
        }
      ).call

      if km_result[:success]
        @maintenance.update!(vehicle_km_id: km_result[:vehicle_km].id)
        @warnings << "Registro de KM creado y vinculado"

        if km_result[:needs_review]
          @warnings << "El registro de KM fue marcado como conflictivo y requiere revisión"
        end
      else
        @errors.concat(km_result[:errors])
        raise ActiveRecord::Rollback
      end
    end

    def success
      {
        success: true,
        maintenance: @maintenance.reload,
        warnings: @warnings
      }
    end

    def failure
      {
        success: false,
        errors: @errors,
        maintenance: @maintenance
      }
    end
  end
end
