# app/api/v1/companies_api.rb
module V1
  class CompaniesApi < Grape::API
    resource :companies do
      desc "Lista todas las compañías"
      params do
        optional :include_deleted, type: Boolean, default: false, desc: "Incluir compañías eliminadas"
        optional :only_deleted, type: Boolean, default: false, desc: "Solo compañías eliminadas"
        optional :with_stats, type: Boolean, default: false, desc: "Incluir estadísticas de cada compañía"
        optional :page, type: Integer, default: 1, desc: "Página"
        optional :per_page, type: Integer, default: 25, desc: "Registros por página"
      end
      get do
        # Base query según parámetros
        companies = if params[:only_deleted]
                      Company.discarded
        elsif params[:include_deleted]
                      Company.with_discarded
        else
                      Company.kept
        end

        companies = companies.page(params[:page]).per(params[:per_page])

        response = present companies, with: Entities::CompanyEntity

        # Agregar estadísticas si se solicita
        if params[:with_stats]
          response[:companies] = companies.map do |company|
            company_data = company.as_json
            company_data[:stats] = company.kept? ? company.km_stats : nil
            company_data
          end
        end

        response
      end

      desc "Obtener una compañía específica"
      params do
        requires :id, type: Integer, desc: "ID de la compañía"
        optional :include_deleted, type: Boolean, default: false
        optional :include_stats, type: Boolean, default: false, desc: "Incluir estadísticas completas"
      end
      route_param :id do
        get do
          company = if params[:include_deleted]
                      Company.with_discarded.find(params[:id])
          else
                      Company.kept.find(params[:id])
          end

          response = present(company, with: Entities::CompanyEntity)

          if params[:include_stats] && company.kept?
            response.merge!(
              stats: company.km_stats,
              vehicles_count: company.vehicles.kept.count,
              vehicle_kms_count: company.vehicle_kms.kept.count,
              maintenances_count: company.maintenances.kept.count
            )
          end

          response
        end
      end

      desc "Crear una nueva compañía"
      params do
        requires :name, type: String, desc: "Nombre de la compañía"
        optional :cif, type: String, desc: "CIF de la compañía"
        optional :max_daily_km_tolerance, type: Integer, desc: "Tolerancia máxima de KM diarios"
      end
      post do
        company = Company.create!(declared_params)
        present company, with: Entities::CompanyEntity
      end

      desc "Actualizar una compañía"
      params do
        requires :id, type: Integer, desc: "ID de la compañía"
        optional :name, type: String, desc: "Nombre de la compañía"
        optional :cif, type: String, desc: "CIF de la compañía"
      end
      route_param :id do
        put do
          company = Company.kept.find(params[:id])
          company.update!(declared_params.except(:id))
          present company, with: Entities::CompanyEntity
        end
      end

      desc "Eliminar una compañía (soft delete con cascada automática de TODOS los datos)"
      params do
        requires :id, type: Integer, desc: "ID de la compañía"
        optional :force, type: Boolean, default: false, desc: "Forzar eliminación ignorando advertencias"
        optional :preview, type: Boolean, default: false, desc: "Solo mostrar el impacto sin ejecutar"
        optional :confirm_massive, type: Boolean, default: false, desc: "Confirmar operación masiva (>1000 registros)"
      end
      route_param :id do
        delete do
          company = Company.kept.find(params[:id])

          # Crear coordinador
          coordinator = SoftDelete::DeletionCoordinator.new(company,
            force: params[:force]
          )

          # Si se pide preview, solo analizar
          if params[:preview]
            preview = coordinator.preview

            # Calcular datos adicionales
            total_vehicles = company.vehicles.kept.count
            total_kms = company.vehicle_kms.kept.count
            total_maintenances = company.maintenances.kept.count
            total_records = total_vehicles + total_kms + total_maintenances

            risk_level = company.deletion_risk_level

            return present({
              success: true,
              preview: preview,
              company_id: company.id,
              company_info: {
                name: company.name,
                cif: company.cif
              },
              impact_summary: {
                total_records_to_delete: total_records,
                vehicles_count: total_vehicles,
                vehicle_kms_count: total_kms,
                maintenances_count: total_maintenances,
                vehicles_with_conflicts: company.vehicles.kept.with_conflictive_kms.count,
                conflictive_kms_count: company.vehicle_kms.kept.conflictive.count,
                total_maintenance_cost: company.maintenances.kept.sum(:amount).to_f,
                estimated_time: preview.dig(:impact, :estimated_time),
                is_massive_operation: total_records > 100,
                requires_background_job: total_records > 1000
              },
              risk_level: risk_level
            })
          end

          # PROTECCIÓN: Verificar si es operación masiva crítica
          total_records = company.vehicles.kept.count +
                         company.vehicle_kms.kept.count +
                         company.maintenances.kept.count

          if total_records > 1000 && !params[:confirm_massive]
            error!({
              success: false,
              errors: [
                "Esta compañía tiene #{total_records} registros. Esta es una operación masiva crítica."
              ],
              message: "Operación masiva requiere confirmación adicional",
              requires_confirm_massive: true,
              total_records: total_records,
              recommendation: "Use confirm_massive=true para confirmar esta operación o considere usar un job en segundo plano"
            }, 422)
          end

          # Ejecutar borrado
          result = coordinator.call

          if result[:success]
            present({
              success: true,
              message: result[:message],
              company_id: company.id,
              impact: {
                cascade_count: result[:cascade_count] || 0,
                nullify_count: result[:nullify_count] || 0
              },
              warnings: result[:warnings] || [],
              audit_log_id: result[:audit_log]&.id
            })
          else
            error!({
              success: false,
              errors: result[:errors],
              warnings: result[:warnings],
              message: result[:message],
              requires_force: result[:requires_force],
              impact: result[:impact]
            }, 422)
          end
        end
      end

      desc "Restaurar una compañía eliminada"
      params do
        requires :id, type: Integer, desc: "ID de la compañía eliminada"
        optional :cascade_restore, type: Boolean, default: false, desc: "Restaurar también todos los vehículos, KMs y mantenimientos"
        optional :preview, type: Boolean, default: false, desc: "Solo mostrar viabilidad sin ejecutar"
        optional :confirm_massive, type: Boolean, default: false, desc: "Confirmar restauración masiva (>1000 registros)"
      end
      route_param :id do
        post :restore do
          company = Company.discarded.find(params[:id])

          # Preparar opciones
          options = {
            cascade_restore: params[:cascade_restore]
          }

          # Crear coordinador
          coordinator = SoftDelete::RestorationCoordinator.new(company, options)

          # Si se pide preview, solo analizar
          if params[:preview]
            preview = coordinator.preview

            # Calcular totales de cascadas
            cascaded = preview.dig(:restoration_info, :cascaded_records) || []
            total_cascaded = cascaded.sum { |c| c[:count] }

            vehicles_discarded = cascaded.find { |c| c[:relation] == "Vehicles" }&.dig(:count) || 0
            kms_discarded = cascaded.find { |c| c[:relation] == "Vehicle Kms" }&.dig(:count) || 0
            maintenances_discarded = cascaded.find { |c| c[:relation] == "Maintenances" }&.dig(:count) || 0

            return present({
              success: true,
              preview: preview,
              company_id: company.id,
              company_info: {
                name: company.name,
                cif: company.cif,
                deleted_at: company.discarded_at
              },
              restoration_summary: {
                total_cascaded_records: total_cascaded,
                vehicles_discarded: vehicles_discarded,
                vehicle_kms_discarded: kms_discarded,
                maintenances_discarded: maintenances_discarded,
                estimated_time: preview.dig(:restoration_info, :estimated_time),
                is_massive_restoration: total_cascaded > 100,
                requires_background_job: total_cascaded > 1000
              }
            })
          end

          # PROTECCIÓN: Verificar si es restauración masiva crítica
          if params[:cascade_restore]
            total_discarded = company.vehicles.discarded.count +
                            company.vehicle_kms.discarded.count +
                            company.maintenances.discarded.count

            if total_discarded > 1000 && !params[:confirm_massive]
              error!({
                success: false,
                errors: [
                  "Esta restauración en cascada involucra #{total_discarded} registros. Esta es una operación masiva crítica."
                ],
                message: "Restauración masiva requiere confirmación adicional",
                requires_confirm_massive: true,
                total_records: total_discarded,
                recommendation: "Use confirm_massive=true para confirmar o considere restaurar sin cascada primero"
              }, 422)
            end
          end

          # Ejecutar restauración
          result = coordinator.call

          if result[:success]
            present({
              success: true,
              message: result[:message],
              company: present(result[:record], with: Entities::CompanyEntity),
              restored_count: result[:restored_count] || 1,
              warnings: result[:warnings] || [],
              audit_log_id: result[:audit_log]&.id
            })
          else
            error!({
              success: false,
              errors: result[:errors],
              message: result[:message],
              conflicts: result[:conflicts],
              required_decisions: result[:required_decisions]
            }, 422)
          end
        end
      end

      desc "Verificar si una compañía puede ser eliminada"
      params do
        requires :id, type: Integer, desc: "ID de la compañía"
      end
      route_param :id do
        get :can_delete do
          company = Company.kept.find(params[:id])
          impact = company.deletion_impact

          total_vehicles = company.vehicles.kept.count
          total_kms = company.vehicle_kms.kept.count
          total_maintenances = company.maintenances.kept.count
          total_records = total_vehicles + total_kms + total_maintenances

          present({
            success: true,
            can_delete: company.can_be_deleted?,
            requires_force: impact[:warnings].any?,
            impact: impact,
            summary: {
              total_records_to_delete: total_records,
              vehicles_count: total_vehicles,
              vehicle_kms_count: total_kms,
              maintenances_count: total_maintenances,
              vehicles_with_conflicts: company.vehicles.kept.with_conflictive_kms.count,
              conflictive_kms_count: company.vehicle_kms.kept.conflictive.count,
              total_maintenance_cost: company.maintenances.kept.sum(:amount).to_f,
              estimated_time: impact[:estimated_time],
              is_massive_operation: total_records > 100,
              requires_background_job: total_records > 1000
            },
            risk_level: company.deletion_risk_level
          })
        end
      end

      desc "Verificar si una compañía eliminada puede ser restaurada"
      params do
        requires :id, type: Integer, desc: "ID de la compañía eliminada"
      end
      route_param :id do
        get :can_restore do
          company = Company.discarded.find(params[:id])
          info = company.restoration_info

          cascaded = info[:cascaded_records] || []
          total_cascaded = cascaded.sum { |c| c[:count] }

          present({
            success: true,
            can_restore: company.can_be_restored?,
            restoration_info: info,
            summary: {
              total_cascaded_records: total_cascaded,
              is_massive_restoration: total_cascaded > 100,
              requires_background_job: total_cascaded > 1000,
              restore_options_count: info[:restore_options]&.count || 0
            }
          })
        end
      end

      desc "Obtener resumen completo del impacto de borrado"
      params do
        requires :id, type: Integer, desc: "ID de la compañía"
      end
      route_param :id do
        get :deletion_summary do
          company = Company.kept.find(params[:id])
          summary = company.deletion_impact_summary

          present({
            success: true,
            company_id: company.id,
            company_info: {
              name: company.name,
              cif: company.cif
            },
            summary: summary,
            risk_level: company.deletion_risk_level
          })
        end
      end

      desc "Obtener información de restauración de una compañía eliminada"
      params do
        requires :id, type: Integer, desc: "ID de la compañía eliminada"
      end
      route_param :id do
        get :restoration_viability do
          company = Company.discarded.find(params[:id])
          viability = company.restoration_viability

          present({
            success: true,
            company_id: company.id,
            company_info: {
              name: company.name,
              cif: company.cif,
              deleted_at: company.discarded_at
            },
            viability: viability
          })
        end
      end

      desc "Obtener estado de eliminación de una compañía"
      params do
        requires :id, type: Integer, desc: "ID de la compañía"
      end
      route_param :id do
        get :deletion_status do
          company = Company.with_discarded.find(params[:id])

          status_info = {
            company_id: company.id,
            name: company.name,
            is_deleted: company.discarded?,
            status_description: company.deletion_status_description
          }

          if company.discarded?
            # Información adicional para compañías eliminadas
            deletion_log = SoftDeleteAuditLog
              .deletions
              .for_record(company)
              .order(performed_at: :desc)
              .first

            status_info.merge!(
              deleted_at: company.discarded_at,
              can_be_restored: company.can_be_restored?,
              deletion_log_id: deletion_log&.id,
              cascade_count: deletion_log&.cascade_count || 0,
              restore_complexity: deletion_log&.restore_complexity,
              deletion_context: deletion_log&.context
            )
          else
            # Información adicional para compañías activas
            status_info.merge!(
              total_vehicles: company.vehicles.kept.count,
              total_vehicle_kms: company.vehicle_kms.kept.count,
              total_maintenances: company.maintenances.kept.count,
              vehicles_with_conflicts: company.vehicles.kept.with_conflictive_kms.count
            )
          end

          present(status_info)
        end
      end

      desc "Exportar datos de una compañía antes de eliminar (placeholder)"
      params do
        requires :id, type: Integer, desc: "ID de la compañía"
      end
      route_param :id do
        get :export_data do
          company = Company.kept.find(params[:id])
          export = company.export_data_before_deletion

          present({
            success: true,
            company_id: company.id,
            export: export,
            message: "Datos exportados correctamente. Considere guardar esta información antes de eliminar la compañía."
          })
        end
      end

      desc "Obtener estadísticas de soft delete de todas las compañías"
      get :deletion_stats do
        stats = {
          total_companies: Company.kept.count,
          deleted_companies: Company.discarded.count,
          companies_at_risk: Company.kept.select { |c|
            total = c.vehicles.kept.count + c.vehicle_kms.kept.count + c.maintenances.kept.count
            total > 500
          }.count,
          by_risk_level: {
            low: 0,
            medium: 0,
            high: 0,
            critical: 0
          }
        }

        Company.kept.each do |company|
          risk = company.deletion_risk_level
          stats[:by_risk_level][risk[:level]] += 1
        end

        present({
          success: true,
          stats: stats
        })
      end
    end
  end
end

# app/api/v1/maintenances_api.rb
module V1
  class MaintenancesApi < Grape::API
    resource :maintenances do
      desc "Lista mantenimientos"
      params do
        optional :vehicle_id, type: Integer, desc: "Filtrar por vehículo"
        optional :from_date, type: Date, desc: "Fecha desde"
        optional :to_date, type: Date, desc: "Fecha hasta"
        optional :include_vehicle, type: Boolean, default: false
        optional :include_vehicle_km, type: Boolean, default: false
        optional :include_deleted, type: Boolean, default: false, desc: "Incluir mantenimientos eliminados"
        optional :page, type: Integer, default: 1
        optional :per_page, type: Integer, default: 25
      end
      get do
        # Base query: kept por defecto, o with_discarded si se pide
        maintenances = if params[:include_deleted]
                         Maintenance.with_discarded.includes(:vehicle, :company, :vehicle_km)
        else
                         Maintenance.kept.includes(:vehicle, :company, :vehicle_km)
        end

        maintenances = maintenances.where(vehicle_id: params[:vehicle_id]) if params[:vehicle_id]

        if params[:from_date] && params[:to_date]
          maintenances = maintenances.where(maintenance_date: params[:from_date]..params[:to_date])
        end

        maintenances = maintenances.ordered.page(params[:page]).per(params[:per_page])

        present maintenances, with: Entities::MaintenanceEntity,
                             include_vehicle: params[:include_vehicle],
                             include_vehicle_km: params[:include_vehicle_km]
      end

      desc "Obtener detalle completo de un mantenimiento"
      params do
        requires :id, type: Integer, desc: "ID del mantenimiento"
        optional :include_deleted, type: Boolean, default: false
      end
      route_param :id do
        get do
          maintenance = if params[:include_deleted]
                          Maintenance.with_discarded.includes(:vehicle, :vehicle_km, :company).find(params[:id])
          else
                          Maintenance.kept.includes(:vehicle, :vehicle_km, :company).find(params[:id])
          end

          present maintenance, with: Entities::MaintenanceDetailEntity
        end
      end

      desc "Crear un nuevo mantenimiento"
      params do
        requires :vehicle_id, type: Integer, desc: "ID del vehículo"
        requires :maintenance_date, type: Date, desc: "Fecha del mantenimiento"
        requires :register_km, type: Integer, desc: "Kilómetros registrados"
        optional :amount, type: BigDecimal, desc: "Importe"
        optional :description, type: String, desc: "Descripción"
        optional :create_km_record, type: Boolean, default: true, desc: "Crear registro de KM automáticamente"
      end
      post do
        result = Maintenances::CreateService.new(
          vehicle_id: params[:vehicle_id],
          params: declared_params.except(:vehicle_id)
        ).call

        if result[:success]
          response_data = {
            success: true,
            maintenance: present(result[:maintenance], with: Entities::MaintenanceDetailEntity)
          }

          response_data[:warnings] = result[:warnings] if result[:warnings].any?
          response_data
        else
          error!({ success: false, errors: result[:errors] }, 422)
        end
      end

      desc "Actualizar un mantenimiento"
      params do
        requires :id, type: Integer, desc: "ID del mantenimiento"
        optional :maintenance_date, type: Date, desc: "Fecha del mantenimiento"
        optional :register_km, type: Integer, desc: "Kilómetros registrados"
        optional :amount, type: BigDecimal, desc: "Importe"
        optional :description, type: String, desc: "Descripción"
        optional :update_km_record, type: Boolean, default: false, desc: "Actualizar también el registro de KM"
      end
      route_param :id do
        put do
          result = Maintenances::UpdateService.new(
            maintenance_id: params[:id],
            params: declared_params.except(:id)
          ).call

          if result[:success]
            response_data = {
              success: true,
              maintenance: present(result[:maintenance], with: Entities::MaintenanceDetailEntity)
            }

            response_data[:warnings] = result[:warnings] if result[:warnings].any?
            response_data
          else
            error!({ success: false, errors: result[:errors] }, 422)
          end
        end
      end

      desc "Eliminar un mantenimiento (soft delete con cascada opcional)"
      params do
        requires :id, type: Integer, desc: "ID del mantenimiento"
        optional :force, type: Boolean, default: false, desc: "Forzar eliminación ignorando advertencias"
        optional :preview, type: Boolean, default: false, desc: "Solo mostrar el impacto sin ejecutar"
        optional :delete_vehicle_km, type: String,
                 values: [ "delete", "keep" ],
                 desc: "Decisión sobre el VehicleKm asociado (si existe)"
      end
      route_param :id do
        delete do
          maintenance = Maintenance.kept.find(params[:id])

          # Preparar opciones de cascada si se especificaron
          cascade_options = {}
          if params[:delete_vehicle_km].present?
            cascade_options[:vehicle_km] = params[:delete_vehicle_km]
          end

          # Crear coordinador
          coordinator = SoftDelete::DeletionCoordinator.new(maintenance,
            force: params[:force],
            cascade_options: cascade_options
          )

          # Si se pide preview, solo analizar
          if params[:preview]
            preview = coordinator.preview
            return present({
              success: true,
              preview: preview,
              maintenance_id: maintenance.id,
              has_vehicle_km: maintenance.vehicle_km.present?,
              vehicle_km_info: maintenance.vehicle_km.present? ? {
                id: maintenance.vehicle_km.id,
                from_maintenance: maintenance.vehicle_km.from_maintenance?,
                can_delete_cascade: maintenance.can_delete_vehicle_km_cascade?
              } : nil
            })
          end

          # Ejecutar borrado
          result = coordinator.call

          if result[:success]
            present({
              success: true,
              message: result[:message],
              maintenance_id: maintenance.id,
              impact: {
                cascade_count: result[:cascade_count],
                nullify_count: result[:nullify_count]
              },
              warnings: result[:warnings],
              vehicle_km_deleted: result[:cascade_count] > 0
            })
          else
            error!({
              success: false,
              errors: result[:errors],
              warnings: result[:warnings],
              message: result[:message],
              requires_force: result[:requires_force],
              optional_cascades: result[:optional_cascades],
              impact: result[:impact]
            }, 422)
          end
        end
      end

      desc "Restaurar un mantenimiento eliminado"
      params do
        requires :id, type: Integer, desc: "ID del mantenimiento eliminado"
        optional :cascade_restore, type: Boolean, default: false, desc: "Restaurar también el VehicleKm en cascada"
        optional :reassign_to, type: Hash, desc: "Reasignar a otro vehículo si el original fue eliminado"
        optional :preview, type: Boolean, default: false, desc: "Solo mostrar viabilidad sin ejecutar"
      end
      route_param :id do
        post :restore do
          maintenance = Maintenance.discarded.find(params[:id])

          # Preparar opciones
          options = {
            cascade_restore: params[:cascade_restore]
          }

          if params[:reassign_to].present?
            options[:reassign_to] = params[:reassign_to].symbolize_keys
          end

          # Crear coordinador
          coordinator = SoftDelete::RestorationCoordinator.new(maintenance, options)

          # Si se pide preview, solo analizar
          if params[:preview]
            preview = coordinator.preview
            return present({
              success: true,
              preview: preview,
              maintenance_id: maintenance.id,
              has_cascaded_vehicle_km: preview.dig(:restoration_info, :cascaded_records)&.any?
            })
          end

          # Ejecutar restauración
          result = coordinator.call

          if result[:success]
            present({
              success: true,
              message: result[:message],
              maintenance: present(result[:record], with: Entities::MaintenanceDetailEntity),
              restored_count: result[:restored_count],
              warnings: result[:warnings]
            })
          else
            error!({
              success: false,
              errors: result[:errors],
              message: result[:message],
              conflicts: result[:conflicts],
              required_decisions: result[:required_decisions]
            }, 422)
          end
        end
      end

      desc "Verificar si un mantenimiento puede ser eliminado"
      params do
        requires :id, type: Integer, desc: "ID del mantenimiento"
      end
      route_param :id do
        get :can_delete do
          maintenance = Maintenance.kept.find(params[:id])
          impact = maintenance.deletion_impact

          present({
            success: true,
            can_delete: maintenance.can_be_deleted?,
            requires_force: impact[:warnings].any?,
            has_optional_cascades: impact[:will_cascade].any? { |c| c[:optional] },
            vehicle_km_info: maintenance.vehicle_km.present? ? {
              id: maintenance.vehicle_km.id,
              from_maintenance: maintenance.vehicle_km.from_maintenance?,
              can_delete_cascade: maintenance.can_delete_vehicle_km_cascade?,
              status_description: maintenance.vehicle_km_status_description
            } : nil,
            impact: impact
          })
        end
      end

      desc "Verificar si un mantenimiento eliminado puede ser restaurado"
      params do
        requires :id, type: Integer, desc: "ID del mantenimiento eliminado"
      end
      route_param :id do
        get :can_restore do
          maintenance = Maintenance.discarded.find(params[:id])
          info = maintenance.restoration_info

          present({
            success: true,
            can_restore: maintenance.can_be_restored?,
            has_cascaded_vehicle_km: info[:cascaded_records]&.any?,
            restoration_info: info
          })
        end
      end

      desc "Obtener resumen del impacto de borrado"
      params do
        requires :id, type: Integer, desc: "ID del mantenimiento"
      end
      route_param :id do
        get :deletion_summary do
          maintenance = Maintenance.kept.find(params[:id])
          summary = maintenance.deletion_impact_summary

          present({
            success: true,
            maintenance_id: maintenance.id,
            summary: summary,
            vehicle_km_info: maintenance.vehicle_km.present? ? {
              id: maintenance.vehicle_km.id,
              status: maintenance.vehicle_km.status,
              from_maintenance: maintenance.vehicle_km.from_maintenance?,
              status_description: maintenance.vehicle_km_status_description
            } : nil
          })
        end
      end

      desc "Sincronizar KM del mantenimiento con el histórico"
      params do
        requires :id, type: Integer, desc: "ID del mantenimiento"
      end
      route_param :id do
        post :sync_km do
          result = Maintenances::SyncKmService.new(
            maintenance_id: params[:id]
          ).call

          if result[:success]
            {
              success: true,
              message: result[:message],
              maintenance: present(result[:maintenance], with: Entities::MaintenanceDetailEntity)
            }
          else
            error!({ success: false, errors: result[:errors] }, 422)
          end
        end
      end

      desc "Obtener alertas de mantenimientos con problemas de KM"
      params do
        optional :vehicle_id, type: Integer, desc: "Filtrar por vehículo"
        optional :alert_type, type: String,
                 values: %w[eliminado sin_registro desincronizado conflictivo],
                 desc: "Tipo de alerta"
      end
      get :alerts do
        result = Maintenances::AlertsService.new(
          vehicle_id: params[:vehicle_id],
          alert_type: params[:alert_type]
        ).call

        result
      end
    end
  end
end
# app/api/v1/soft_delete_api.rb
module V1
  class SoftDeleteApi < Grape::API
    namespace :soft_delete do
      desc "Analizar el impacto de borrar un registro (preview)"
      params do
        requires :record_type, type: String, desc: "Tipo de modelo (Company, Vehicle, VehicleKm, Maintenance)"
        requires :record_id, type: Integer, desc: "ID del registro"
      end
      post :deletion_preview do
        # Validar y obtener registro
        record = find_record(params[:record_type], params[:record_id])
        error!({ error: "Registro no encontrado" }, 404) unless record

        # Crear coordinador y obtener preview
        coordinator = SoftDelete::DeletionCoordinator.new(record)
        preview = coordinator.preview

        # Respuesta estructurada
        present({
          success: true,
          record_type: params[:record_type],
          record_id: params[:record_id],
          preview: preview
        })
      end

      desc "Ejecutar el borrado de un registro"
      params do
        requires :record_type, type: String, desc: "Tipo de modelo"
        requires :record_id, type: Integer, desc: "ID del registro"
        optional :force, type: Boolean, default: false, desc: "Forzar borrado ignorando warnings"
        optional :cascade_options, type: Hash, desc: "Decisiones sobre cascadas opcionales"
        optional :user_id, type: Integer, desc: "ID del usuario que ejecuta la acción"
      end
      delete :execute do
        # Validar y obtener registro
        record = find_record(params[:record_type], params[:record_id])
        error!({ error: "Registro no encontrado" }, 404) unless record

        # Obtener usuario si se especificó
        user = params[:user_id] ? find_user(params[:user_id]) : nil

        # Crear coordinador con opciones
        coordinator = SoftDelete::DeletionCoordinator.new(record,
          force: params[:force],
          cascade_options: params[:cascade_options] || {},
          user: user
        )

        # Ejecutar borrado
        result = coordinator.call

        if result[:success]
          # Respuesta exitosa
          present({
            success: true,
            record_type: params[:record_type],
            record_id: params[:record_id],
            message: result[:message],
            audit_log_id: result[:audit_log]&.id,
            impact: {
              cascade_count: result[:cascade_count],
              nullify_count: result[:nullify_count]
            },
            warnings: result[:warnings]
          })
        else
          # Error estructurado
          error!({
            success: false,
            errors: result[:errors],
            warnings: result[:warnings],
            message: result[:message],
            requires_force: result[:requires_force],
            optional_cascades: result[:optional_cascades],
            impact: result[:impact]
          }, 422)
        end
      end

      desc "Analizar la viabilidad de restaurar un registro (preview)"
      params do
        requires :record_type, type: String, desc: "Tipo de modelo"
        requires :record_id, type: Integer, desc: "ID del registro eliminado"
      end
      post :restoration_preview do
        # Validar y obtener registro eliminado
        record = find_discarded_record(params[:record_type], params[:record_id])
        error!({ error: "Registro no encontrado o no está eliminado" }, 404) unless record

        # Crear coordinador y obtener preview
        coordinator = SoftDelete::RestorationCoordinator.new(record)
        preview = coordinator.preview

        # Respuesta estructurada
        present({
          success: true,
          record_type: params[:record_type],
          record_id: params[:record_id],
          preview: preview
        })
      end

      desc "Ejecutar la restauración de un registro eliminado"
      params do
        requires :record_type, type: String, desc: "Tipo de modelo"
        requires :record_id, type: Integer, desc: "ID del registro eliminado"
        optional :cascade_restore, type: Boolean, default: false, desc: "Restaurar en cascada"
        optional :selected_cascades, type: Array[String], desc: "Cascadas específicas a restaurar"
        optional :reassign_to, type: Hash, desc: "Reasignación de relaciones padre"
        optional :user_id, type: Integer, desc: "ID del usuario que ejecuta la acción"
      end
      post :restore do
        # Validar y obtener registro eliminado
        record = find_discarded_record(params[:record_type], params[:record_id])
        error!({ error: "Registro no encontrado o no está eliminado" }, 404) unless record

        # Obtener usuario si se especificó
        user = params[:user_id] ? find_user(params[:user_id]) : nil

        # Preparar opciones
        options = {
          cascade_restore: params[:cascade_restore],
          user: user
        }

        # Agregar selected_cascades si se especificó
        if params[:selected_cascades].present?
          options[:selected_cascades] = params[:selected_cascades].map(&:to_sym)
        end

        # Agregar reassign_to si se especificó
        if params[:reassign_to].present?
          options[:reassign_to] = symbolize_keys(params[:reassign_to])
        end

        # Crear coordinador con opciones
        coordinator = SoftDelete::RestorationCoordinator.new(record, options)

        # Ejecutar restauración
        result = coordinator.call

        if result[:success]
          # Respuesta exitosa
          present({
            success: true,
            record_type: params[:record_type],
            record_id: params[:record_id],
            message: result[:message],
            audit_log_id: result[:audit_log]&.id,
            restored_count: result[:restored_count],
            warnings: result[:warnings]
          })
        else
          # Error estructurado
          error!({
            success: false,
            errors: result[:errors],
            warnings: result[:warnings],
            message: result[:message],
            conflicts: result[:conflicts],
            required_decisions: result[:required_decisions],
            restoration_info: result[:restoration_info]
          }, 422)
        end
      end

      # ==========================================================================
      # LOGS DE AUDITORÍA
      # ==========================================================================

      desc "Obtener logs de auditoría"
      params do
        optional :record_type, type: String, desc: "Filtrar por tipo de modelo"
        optional :record_id, type: Integer, desc: "Filtrar por ID específico"
        optional :action, type: String, values: [ "delete", "restore" ], desc: "Filtrar por acción"
        optional :from_date, type: Date, desc: "Desde fecha"
        optional :to_date, type: Date, desc: "Hasta fecha"
        optional :page, type: Integer, default: 1, desc: "Página"
        optional :per_page, type: Integer, default: 25, desc: "Registros por página"
      end
      get :audit_logs do
        # Construir query base
        logs = SoftDeleteAuditLog.all

        # Filtrar por tipo de registro
        if params[:record_type].present?
          logs = logs.where(record_type: params[:record_type])
        end

        # Filtrar por ID específico
        if params[:record_id].present?
          logs = logs.where(record_id: params[:record_id])
        end

        # Filtrar por acción
        if params[:action].present?
          logs = if params[:action] == "delete"
                   logs.deletions
          else
                   logs.restorations
          end
        end

        # Filtrar por rango de fechas
        if params[:from_date] && params[:to_date]
          logs = logs.between_dates(params[:from_date], params[:to_date])
        end

        # Ordenar y paginar
        logs = logs.recent.page(params[:page]).per(params[:per_page])

        # Respuesta
        present({
          success: true,
          logs: logs.map { |log| format_audit_log(log) },
          pagination: {
            current_page: logs.current_page,
            total_pages: logs.total_pages,
            total_count: logs.total_count,
            per_page: params[:per_page]
          }
        })
      end

      desc "Obtener un log de auditoría específico"
      params do
        requires :id, type: Integer, desc: "ID del log"
      end
      route_param :id do
        get :audit_log do
          log = SoftDeleteAuditLog.find(params[:id])

          present({
            success: true,
            log: format_audit_log_detailed(log)
          })
        end
      end

      desc "Obtener estadísticas de soft delete"
      get :stats do
        stats = SoftDeleteAuditLog.deletion_stats

        present({
          success: true,
          stats: {
            total_deletions: stats[:total_deletions],
            total_restorations: stats[:total_restorations],
            by_model: stats[:by_model],
            cascade_impact: stats[:cascade_impact],
            nullify_impact: stats[:nullify_impact],
            massive_operations: stats[:massive_operations],
            restorable_count: stats[:restorable_count]
          }
        })
      end

      desc "Obtener estadísticas por modelo"
      params do
        requires :model, type: String, desc: "Nombre del modelo"
      end
      get :model_stats do
        model_class = constantize_model(params[:model])
        error!({ error: "Modelo no válido" }, 400) unless model_class

        stats = SoftDeleteAuditLog.stats_for_model(model_class)

        present({
          success: true,
          model: params[:model],
          stats: stats
        })
      end

      desc "Obtener registros pendientes de restauración"
      params do
        optional :model, type: String, desc: "Filtrar por modelo"
      end
      get :pending_restorations do
        logs = SoftDeleteAuditLog.pending_restorations

        # Filtrar por modelo si se especificó
        if params[:model].present?
          logs = logs.where(record_type: params[:model])
        end

        present({
          success: true,
          pending_count: logs.count,
          records: logs.limit(100).map { |log| format_pending_restoration(log) }
        })
      end

      # ==========================================================================
      # UTILIDADES
      # ==========================================================================

      desc "Verificar si un registro puede ser borrado"
      params do
        requires :record_type, type: String, desc: "Tipo de modelo"
        requires :record_id, type: Integer, desc: "ID del registro"
      end
      get :can_delete do
        record = find_record(params[:record_type], params[:record_id])
        error!({ error: "Registro no encontrado" }, 404) unless record

        can_delete = record.can_be_deleted?
        impact = record.deletion_impact

        present({
          success: true,
          can_delete: can_delete,
          requires_force: !can_delete && impact[:warnings].any?,
          blockers: impact[:blockers],
          recommendation: impact[:recommendation]
        })
      end

      desc "Verificar si un registro puede ser restaurado"
      params do
        requires :record_type, type: String, desc: "Tipo de modelo"
        requires :record_id, type: Integer, desc: "ID del registro eliminado"
      end
      get :can_restore do
        record = find_discarded_record(params[:record_type], params[:record_id])
        error!({ error: "Registro no encontrado o no está eliminado" }, 404) unless record

        can_restore = record.can_be_restored?
        info = record.restoration_info

        present({
          success: true,
          can_restore: can_restore,
          conflicts: info[:conflicts],
          recommendation: info[:recommendation]
        })
      end
    end

    helpers do
      # Encuentra un registro activo por tipo y ID
      def find_record(record_type, record_id)
        model_class = constantize_model(record_type)
        return nil unless model_class

        model_class.kept.find_by(id: record_id)
      end

      # Encuentra un registro eliminado por tipo y ID
      def find_discarded_record(record_type, record_id)
        model_class = constantize_model(record_type)
        return nil unless model_class

        model_class.discarded.find_by(id: record_id)
      end

      # Convierte string a clase de modelo
      def constantize_model(model_name)
        valid_models = %w[Company Vehicle VehicleKm Maintenance]
        return nil unless valid_models.include?(model_name)

        model_name.constantize
      rescue NameError
        nil
      end

      # Encuentra usuario (ajustar según tu sistema de autenticación)
      def find_user(user_id)
        # Ejemplo: User.find_by(id: user_id)
        # Por ahora retornamos un objeto genérico
        OpenStruct.new(id: user_id, class: OpenStruct.new(name: "User"))
      end

      # Convierte claves de hash a símbolos
      def symbolize_keys(hash)
        hash.transform_keys(&:to_sym)
      end

      # Formatea un log de auditoría (versión resumida)
      def format_audit_log(log)
        {
          id: log.id,
          record_type: log.record_type,
          record_id: log.record_id,
          action: log.action,
          performed_at: log.performed_at,
          cascade_count: log.cascade_count,
          nullify_count: log.nullify_count,
          can_restore: log.can_restore,
          restore_complexity: log.restore_complexity,
          performed_by: log.performed_by_description
        }
      end

      # Formatea un log de auditoría (versión detallada)
      def format_audit_log_detailed(log)
        {
          id: log.id,
          record_type: log.record_type,
          record_id: log.record_id,
          action: log.action,
          performed_at: log.performed_at,
          cascade_count: log.cascade_count,
          nullify_count: log.nullify_count,
          total_impact: log.total_impact,
          can_restore: log.can_restore,
          restore_complexity: log.restore_complexity,
          complexity_badge: log.complexity_badge,
          performed_by: log.performed_by_description,
          context: log.context,
          action_description: log.action_description,
          impact_description: log.impact_description,
          record_exists: log.record_exists?,
          record_discarded: log.record_discarded?,
          currently_restorable: log.currently_restorable?
        }
      end

      # Formatea registro pendiente de restauración
      def format_pending_restoration(log)
        {
          id: log.id,
          record_type: log.record_type,
          record_id: log.record_id,
          deleted_at: log.performed_at,
          cascade_count: log.cascade_count,
          restore_complexity: log.restore_complexity,
          context: log.context.slice("name", "matricula", "company_name") # Solo datos relevantes
        }
      end
    end
  end
end
# app/api/v1/vehicle_kms_api.rb
module V1
  class VehicleKmsApi < Grape::API
    resource :vehicle_kms do
      desc "Lista registros de KM"
      params do
        optional :vehicle_id, type: Integer, desc: "Filtrar por vehículo"
        optional :status, type: String, values: %w[original corregido editado conflictivo], desc: "Filtrar por estado"
        optional :source_type, type: String, values: %w[manual Maintenance], desc: "Filtrar por tipo de origen"
        optional :needs_review, type: Boolean, desc: "Solo registros que requieren revisión (conflictivos)"
        optional :from_date, type: Date, desc: "Fecha desde"
        optional :to_date, type: Date, desc: "Fecha hasta"
        optional :include_vehicle, type: Boolean, default: false, desc: "Incluir datos del vehículo"
        optional :include_source, type: Boolean, default: false, desc: "Incluir datos del registro origen"
        optional :include_deleted, type: Boolean, default: false, desc: "Incluir registros eliminados"
        optional :page, type: Integer, default: 1
        optional :per_page, type: Integer, default: 25
      end
      get do
        # Base query: kept por defecto, o with_discarded si se pide
        kms = if params[:include_deleted]
                VehicleKm.with_discarded.includes(:vehicle, :company, :source_record)
        else
                VehicleKm.kept.includes(:vehicle, :company, :source_record)
        end

        kms = kms.where(vehicle_id: params[:vehicle_id]) if params[:vehicle_id]
        kms = kms.where(status: params[:status]) if params[:status]
        kms = kms.where(status: "conflictivo") if params[:needs_review]

        # Filtrar por tipo de origen
        if params[:source_type]
          if params[:source_type] == "manual"
            kms = kms.manual
          else
            kms = kms.where(source_record_type: params[:source_type])
          end
        end

        if params[:from_date] && params[:to_date]
          kms = kms.where(input_date: params[:from_date]..params[:to_date])
        end

        kms = kms.order(input_date: :desc, created_at: :desc)
                 .page(params[:page])
                 .per(params[:per_page])

        present kms, with: Entities::VehicleKmEntity,
                include_vehicle: params[:include_vehicle],
                include_source: params[:include_source]
      end

      desc "Obtener un registro de KM específico con detalles"
      params do
        requires :id, type: Integer, desc: "ID del registro"
        optional :include_deleted, type: Boolean, default: false
      end
      route_param :id do
        get do
          km = if params[:include_deleted]
                 VehicleKm.with_discarded.includes(:source_record).find(params[:id])
          else
                 VehicleKm.kept.includes(:source_record).find(params[:id])
          end

          present km, with: Entities::VehicleKmDetailEntity
        end
      end

      desc "Crear un nuevo registro de KM manual"
      params do
        requires :vehicle_id, type: Integer, desc: "ID del vehículo"
        requires :input_date, type: Date, desc: "Fecha del registro"
        requires :km_reported, type: Integer, desc: "Kilómetros reportados"
        optional :notes, type: String, desc: "Notas adicionales"
      end
      post do
        result = VehicleKms::CreateService.new(
          vehicle_id: params[:vehicle_id],
          params: {
            input_date: params[:input_date],
            km_reported: params[:km_reported]
          }
        ).call

        if result[:success]
          response_data = {
            success: true,
            vehicle_km: present(result[:vehicle_km], with: Entities::VehicleKmDetailEntity),
            status: result[:status],
            needs_review: result[:needs_review]
          }

          if result[:needs_review]
            response_data[:warning] = "El registro fue marcado como conflictivo y requiere revisión manual"
          end

          response_data
        else
          error!({ success: false, errors: result[:errors] }, 422)
        end
      end

      desc "Actualizar un registro de KM manualmente"
      params do
        requires :id, type: Integer, desc: "ID del registro"
        optional :km_normalized, type: Integer, desc: "Kilómetros normalizados (corrección manual)"
        optional :km_reported, type: Integer, desc: "Kilómetros reportados"
        optional :status, type: String, values: %w[original corregido editado conflictivo], desc: "Cambiar estado manualmente"
        optional :correction_notes, type: String, desc: "Notas de la corrección manual"
        optional :resolve_conflict, type: Boolean, default: false, desc: "Resolver conflicto manualmente"
      end
      route_param :id do
        put do
          result = VehicleKms::UpdateService.new(
            vehicle_km_id: params[:id],
            params: params.slice(:km_normalized, :km_reported, :status, :correction_notes, :resolve_conflict)
          ).call

          if result[:success]
            present result[:vehicle_km], with: Entities::VehicleKmDetailEntity
          else
            error!({ success: false, errors: result[:errors] }, 422)
          end
        end
      end

      desc "Eliminar un registro de KM (soft delete con análisis de impacto)"
      params do
        requires :id, type: Integer, desc: "ID del registro"
        optional :force, type: Boolean, default: false, desc: "Forzar eliminación ignorando advertencias"
        optional :preview, type: Boolean, default: false, desc: "Solo mostrar el impacto sin ejecutar"
      end
      route_param :id do
        delete do
          vehicle_km = VehicleKm.kept.find(params[:id])

          # Crear coordinador
          coordinator = SoftDelete::DeletionCoordinator.new(vehicle_km,
            force: params[:force]
          )

          # Si se pide preview, solo analizar
          if params[:preview]
            preview = coordinator.preview
            return present({
              success: true,
              preview: preview,
              vehicle_km_id: vehicle_km.id
            })
          end

          # Ejecutar borrado
          result = coordinator.call

          if result[:success]
            present({
              success: true,
              message: result[:message],
              vehicle_km_id: vehicle_km.id,
              impact: {
                nullify_count: result[:nullify_count]
              },
              warnings: result[:warnings],
              maintenance_affected: result[:audit_log]&.context&.dig("maintenance_id")
            })
          else
            error!({
              success: false,
              errors: result[:errors],
              warnings: result[:warnings],
              message: result[:message],
              requires_force: result[:requires_force],
              impact: result[:impact]
            }, 422)
          end
        end
      end

      desc "Restaurar un registro de KM eliminado"
      params do
        requires :id, type: Integer, desc: "ID del registro eliminado"
        optional :reassign_to, type: Hash, desc: "Reasignar a otro vehículo si el original fue eliminado"
        optional :preview, type: Boolean, default: false, desc: "Solo mostrar viabilidad sin ejecutar"
      end
      route_param :id do
        post :restore do
          vehicle_km = VehicleKm.discarded.find(params[:id])

          # Preparar opciones
          options = {}
          if params[:reassign_to].present?
            options[:reassign_to] = params[:reassign_to].symbolize_keys
          end

          # Crear coordinador
          coordinator = SoftDelete::RestorationCoordinator.new(vehicle_km, options)

          # Si se pide preview, solo analizar
          if params[:preview]
            preview = coordinator.preview
            return present({
              success: true,
              preview: preview,
              vehicle_km_id: vehicle_km.id
            })
          end

          # Ejecutar restauración
          result = coordinator.call

          if result[:success]
            present({
              success: true,
              message: result[:message],
              vehicle_km: present(result[:record], with: Entities::VehicleKmDetailEntity),
              restored_count: result[:restored_count]
            })
          else
            error!({
              success: false,
              errors: result[:errors],
              message: result[:message],
              conflicts: result[:conflicts],
              required_decisions: result[:required_decisions]
            }, 422)
          end
        end
      end

      desc "Verificar si un registro puede ser eliminado"
      params do
        requires :id, type: Integer, desc: "ID del registro"
      end
      route_param :id do
        get :can_delete do
          vehicle_km = VehicleKm.kept.find(params[:id])
          impact = vehicle_km.deletion_impact

          present({
            success: true,
            can_delete: vehicle_km.can_be_deleted?,
            requires_force: impact[:warnings].any?,
            impact: impact
          })
        end
      end

      desc "Verificar si un registro eliminado puede ser restaurado"
      params do
        requires :id, type: Integer, desc: "ID del registro eliminado"
      end
      route_param :id do
        get :can_restore do
          vehicle_km = VehicleKm.discarded.find(params[:id])
          info = vehicle_km.restoration_info

          present({
            success: true,
            can_restore: vehicle_km.can_be_restored?,
            restoration_info: info
          })
        end
      end

      desc "Verificar correlación de un registro"
      params do
        requires :id, type: Integer, desc: "ID del registro"
      end
      route_param :id do
        get :check_correlation do
          km = VehicleKm.kept.find(params[:id])

          detector = VehicleKms::ConflictDetectorService.new(km)
          result = detector.call

          prev_record = find_immediate_previous(km)
          next_record = find_immediate_next(km)

          {
            vehicle_km_id: km.id,
            current_status: km.status,
            has_conflict: result[:has_conflict],
            current_is_conflictive: result[:current_is_conflictive],
            conflictive_records_count: result[:conflictive_records].size,
            valid_records_count: result[:valid_records].size,
            previous_record: prev_record ? {
              id: prev_record.id,
              input_date: prev_record.input_date,
              effective_km: prev_record.effective_km,
              status: prev_record.status
            } : nil,
            next_record: next_record ? {
              id: next_record.id,
              input_date: next_record.input_date,
              effective_km: next_record.effective_km,
              status: next_record.status
            } : nil
          }
        end
      end

      desc "Intentar corrección automática de un registro conflictivo"
      params do
        requires :id, type: Integer, desc: "ID del registro"
      end
      route_param :id do
        post :attempt_correction do
          km = VehicleKm.kept.find(params[:id])

          unless km.status == "conflictivo"
            error!({
              success: false,
              errors: [ "Solo se pueden corregir registros conflictivos" ]
            }, 422)
          end

          corrector = VehicleKms::KmCorrectionService.new(km)
          result = corrector.call

          if result[:success] && result[:corrected_km]
            km.update!(
              km_normalized: result[:corrected_km],
              status: "corregido",
              conflict_reasons_list: [],
              correction_notes: result[:notes]
            )

            {
              success: true,
              message: "Corrección aplicada exitosamente",
              vehicle_km: present(km.reload, with: Entities::VehicleKmDetailEntity),
              correction_summary: {
                original_km: km.km_reported,
                corrected_km: result[:corrected_km],
                difference: result[:corrected_km] - km.km_reported,
                method: result[:method]
              }
            }
          else
            error!({
              success: false,
              errors: [ "No se pudo calcular una corrección válida" ],
              details: result[:notes]
            }, 422)
          end
        end
      end

      desc "Recalcular correcciones para un vehículo completo"
      params do
        requires :vehicle_id, type: Integer, desc: "ID del vehículo"
        optional :only_conflictive, type: Boolean, default: true, desc: "Solo recalcular registros conflictivos"
      end
      post :recalculate do
        vehicle = Vehicle.kept.find(params[:vehicle_id])
        kms = VehicleKm.kept
          .where(vehicle_id: vehicle.id)
          .order(input_date: :asc, created_at: :asc)

        kms = kms.where(status: "conflictivo") if params[:only_conflictive]

        results = {
          total_processed: 0,
          corrected: 0,
          still_conflictive: 0,
          errors: []
        }

        kms.each do |km|
          results[:total_processed] += 1

          begin
            corrector = VehicleKms::KmCorrectionService.new(km)
            correction_result = corrector.call

            if correction_result[:success] && correction_result[:corrected_km]
              km.update!(
                km_normalized: correction_result[:corrected_km],
                status: "corregido",
                conflict_reasons_list: [],
                correction_notes: correction_result[:notes]
              )
              results[:corrected] += 1
            else
              results[:still_conflictive] += 1
            end
          rescue StandardError => e
            results[:errors] << { km_id: km.id, error: e.message }
            results[:still_conflictive] += 1
          end
        end

        {
          success: true,
          message: "Procesados #{results[:total_processed]} registros, #{results[:corrected]} corregidos",
          details: results
        }
      end

      desc "Obtener estadísticas de KM por vehículo"
      params do
        requires :vehicle_id, type: Integer, desc: "ID del vehículo"
      end
      get :stats do
        vehicle = Vehicle.kept.find(params[:vehicle_id])
        present vehicle.km_stats.merge(
          vehicle_id: vehicle.id,
          vehicle_matricula: vehicle.matricula
        )
      end

      desc "Obtener lista de vehículos con registros conflictivos"
      params do
        optional :company_id, type: Integer, desc: "Filtrar por compañía"
        optional :min_conflictive, type: Integer, default: 1, desc: "Mínimo de registros conflictivos"
      end
      get :conflictives_summary do
        vehicles = Vehicle.kept.includes(:vehicle_kms)
        vehicles = vehicles.where(company_id: params[:company_id]) if params[:company_id]

        results = vehicles.map do |vehicle|
          total = vehicle.vehicle_kms.kept.count
          conflictive = vehicle.vehicle_kms.kept.where(status: "conflictivo").count

          next if conflictive < params[:min_conflictive]

          {
            vehicle_id: vehicle.id,
            vehicle_matricula: vehicle.matricula,
            vehicle_vin: vehicle.vin,
            total_records: total,
            conflictive_count: conflictive,
            conflictive_percentage: total > 0 ? ((conflictive.to_f / total) * 100).round(2) : 0,
            oldest_conflict: vehicle.vehicle_kms.kept
              .where(status: "conflictivo")
              .minimum(:input_date),
            newest_conflict: vehicle.vehicle_kms.kept
              .where(status: "conflictivo")
              .maximum(:input_date)
          }
        end.compact.sort_by { |r| -r[:conflictive_count] }

        {
          total_vehicles: vehicles.count,
          vehicles_with_conflicts: results.count,
          total_conflictive_records: results.sum { |r| r[:conflictive_count] },
          vehicles: results
        }
      end
    end

    helpers do
      def find_immediate_previous(vehicle_km)
        VehicleKm.kept
          .where(vehicle_id: vehicle_km.vehicle_id)
          .where("input_date < ? OR (input_date = ? AND id < ?)",
                 vehicle_km.input_date,
                 vehicle_km.input_date,
                 vehicle_km.id)
          .order(input_date: :desc, id: :desc)
          .first
      end

      def find_immediate_next(vehicle_km)
        VehicleKm.kept
          .where(vehicle_id: vehicle_km.vehicle_id)
          .where("input_date > ? OR (input_date = ? AND id > ?)",
                 vehicle_km.input_date,
                 vehicle_km.input_date,
                 vehicle_km.id)
          .order(input_date: :asc, id: :asc)
          .first
      end
    end
  end
end
# app/api/v1/vehicles_api.rb
module V1
  class VehiclesApi < Grape::API
    resource :vehicles do
      desc "Lista todos los vehículos"
      params do
        optional :company_id, type: Integer, desc: "Filtrar por compañía"
        optional :include_deleted, type: Boolean, default: false, desc: "Incluir vehículos eliminados"
        optional :only_deleted, type: Boolean, default: false, desc: "Solo vehículos eliminados"
        optional :page, type: Integer, default: 1, desc: "Página"
        optional :per_page, type: Integer, default: 25, desc: "Registros por página"
      end
      get do
        # Base query según parámetros
        vehicles = if params[:only_deleted]
                     Vehicle.discarded.includes(:company)
        elsif params[:include_deleted]
                     Vehicle.with_discarded.includes(:company)
        else
                     Vehicle.kept.includes(:company)
        end

        vehicles = vehicles.where(company_id: params[:company_id]) if params[:company_id]
        vehicles = vehicles.page(params[:page]).per(params[:per_page])

        present vehicles, with: Entities::VehicleEntity
      end

      desc "Obtener un vehículo específico"
      params do
        requires :id, type: Integer, desc: "ID del vehículo"
        optional :include_deleted, type: Boolean, default: false
        optional :include_stats, type: Boolean, default: false, desc: "Incluir estadísticas de KMs y mantenimientos"
      end
      route_param :id do
        get do
          vehicle = if params[:include_deleted]
                      Vehicle.with_discarded.find(params[:id])
          else
                      Vehicle.kept.find(params[:id])
          end

          response = present(vehicle, with: Entities::VehicleEntity)

          if params[:include_stats] && vehicle.kept?
            response.merge!(
              km_stats: vehicle.km_stats,
              maintenance_stats: vehicle.maintenance_stats
            )
          end

          response
        end
      end

      desc "Crear un nuevo vehículo"
      params do
        requires :matricula, type: String, desc: "Matrícula del vehículo"
        optional :vin, type: String, desc: "VIN del vehículo"
        optional :current_km, type: Integer, default: 0, desc: "Kilómetros actuales"
        requires :company_id, type: Integer, desc: "ID de la compañía"
      end
      post do
        vehicle = Vehicle.create!(declared_params)
        present vehicle, with: Entities::VehicleEntity
      end

      desc "Actualizar un vehículo"
      params do
        requires :id, type: Integer, desc: "ID del vehículo"
        optional :matricula, type: String, desc: "Matrícula del vehículo"
        optional :vin, type: String, desc: "VIN del vehículo"
      end
      route_param :id do
        put do
          vehicle = Vehicle.kept.find(params[:id])
          vehicle.update!(declared_params.except(:id))
          present vehicle, with: Entities::VehicleEntity
        end
      end

      desc "Eliminar un vehículo (soft delete con cascada automática de todos los datos)"
      params do
        requires :id, type: Integer, desc: "ID del vehículo"
        optional :force, type: Boolean, default: false, desc: "Forzar eliminación ignorando advertencias"
        optional :preview, type: Boolean, default: false, desc: "Solo mostrar el impacto sin ejecutar"
      end
      route_param :id do
        delete do
          vehicle = Vehicle.kept.find(params[:id])

          # Crear coordinador
          coordinator = SoftDelete::DeletionCoordinator.new(vehicle,
            force: params[:force]
          )

          # Si se pide preview, solo analizar
          if params[:preview]
            preview = coordinator.preview

            # Agregar información adicional útil
            return present({
              success: true,
              preview: preview,
              vehicle_id: vehicle.id,
              vehicle_info: {
                matricula: vehicle.matricula,
                current_km: vehicle.current_km,
                company_name: vehicle.company.name
              },
              impact_summary: {
                total_records_to_delete: preview.dig(:impact, :total_affected) || 0,
                vehicle_kms_count: vehicle.vehicle_kms.kept.count,
                maintenances_count: vehicle.maintenances.kept.count,
                conflictive_kms_count: vehicle.vehicle_kms.kept.conflictive.count,
                estimated_time: preview.dig(:impact, :estimated_time)
              }
            })
          end

          # Ejecutar borrado
          result = coordinator.call

          if result[:success]
            present({
              success: true,
              message: result[:message],
              vehicle_id: vehicle.id,
              impact: {
                cascade_count: result[:cascade_count],
                nullify_count: result[:nullify_count]
              },
              warnings: result[:warnings],
              audit_log_id: result[:audit_log]&.id
            })
          else
            error!({
              success: false,
              errors: result[:errors],
              warnings: result[:warnings],
              message: result[:message],
              requires_force: result[:requires_force],
              impact: result[:impact]
            }, 422)
          end
        end
      end

      desc "Restaurar un vehículo eliminado"
      params do
        requires :id, type: Integer, desc: "ID del vehículo eliminado"
        optional :cascade_restore, type: Boolean, default: false, desc: "Restaurar también KMs y mantenimientos en cascada"
        optional :reassign_to, type: Hash, desc: "Reasignar a otra compañía si la original fue eliminada"
        optional :preview, type: Boolean, default: false, desc: "Solo mostrar viabilidad sin ejecutar"
      end
      route_param :id do
        post :restore do
          vehicle = Vehicle.discarded.find(params[:id])

          # Preparar opciones
          options = {
            cascade_restore: params[:cascade_restore]
          }

          if params[:reassign_to].present?
            options[:reassign_to] = params[:reassign_to].symbolize_keys
          end

          # Crear coordinador
          coordinator = SoftDelete::RestorationCoordinator.new(vehicle, options)

          # Si se pide preview, solo analizar
          if params[:preview]
            preview = coordinator.preview

            # Agregar información adicional
            cascaded = preview.dig(:restoration_info, :cascaded_records) || []
            total_cascaded = cascaded.sum { |c| c[:count] }

            return present({
              success: true,
              preview: preview,
              vehicle_id: vehicle.id,
              vehicle_info: {
                matricula: vehicle.matricula,
                company_name: vehicle.company.name
              },
              restoration_summary: {
                total_cascaded_records: total_cascaded,
                vehicle_kms_discarded: cascaded.find { |c| c[:relation] == "Vehicle Kms" }&.dig(:count) || 0,
                maintenances_discarded: cascaded.find { |c| c[:relation] == "Maintenances" }&.dig(:count) || 0,
                estimated_time: preview.dig(:restoration_info, :estimated_time),
                is_massive_restoration: total_cascaded > 100
              }
            })
          end

          # Ejecutar restauración
          result = coordinator.call

          if result[:success]
            present({
              success: true,
              message: result[:message],
              vehicle: present(result[:record], with: Entities::VehicleEntity),
              restored_count: result[:restored_count],
              warnings: result[:warnings],
              audit_log_id: result[:audit_log]&.id
            })
          else
            error!({
              success: false,
              errors: result[:errors],
              message: result[:message],
              conflicts: result[:conflicts],
              required_decisions: result[:required_decisions]
            }, 422)
          end
        end
      end

      desc "Verificar si un vehículo puede ser eliminado"
      params do
        requires :id, type: Integer, desc: "ID del vehículo"
      end
      route_param :id do
        get :can_delete do
          vehicle = Vehicle.kept.find(params[:id])
          impact = vehicle.deletion_impact

          present({
            success: true,
            can_delete: vehicle.can_be_deleted?,
            requires_force: impact[:warnings].any?,
            impact: impact,
            summary: {
              total_records_to_delete: impact[:total_affected],
              vehicle_kms_count: vehicle.vehicle_kms.kept.count,
              maintenances_count: vehicle.maintenances.kept.count,
              conflictive_kms_count: vehicle.vehicle_kms.kept.conflictive.count,
              estimated_time: impact[:estimated_time],
              is_massive_operation: impact[:total_affected] > 100
            }
          })
        end
      end

      desc "Verificar si un vehículo eliminado puede ser restaurado"
      params do
        requires :id, type: Integer, desc: "ID del vehículo eliminado"
      end
      route_param :id do
        get :can_restore do
          vehicle = Vehicle.discarded.find(params[:id])
          info = vehicle.restoration_info

          cascaded = info[:cascaded_records] || []
          total_cascaded = cascaded.sum { |c| c[:count] }

          present({
            success: true,
            can_restore: vehicle.can_be_restored?,
            restoration_info: info,
            summary: {
              total_cascaded_records: total_cascaded,
              is_massive_restoration: total_cascaded > 100,
              restore_options_count: info[:restore_options]&.count || 0
            }
          })
        end
      end

      desc "Obtener resumen completo del impacto de borrado"
      params do
        requires :id, type: Integer, desc: "ID del vehículo"
      end
      route_param :id do
        get :deletion_summary do
          vehicle = Vehicle.kept.find(params[:id])
          summary = vehicle.deletion_impact_summary

          present({
            success: true,
            vehicle_id: vehicle.id,
            vehicle_info: {
              matricula: vehicle.matricula,
              vin: vehicle.vin,
              current_km: vehicle.current_km,
              company_name: vehicle.company.name
            },
            summary: summary,
            risk_level: vehicle.deletion_risk_level
          })
        end
      end

      desc "Obtener información de restauración de un vehículo eliminado"
      params do
        requires :id, type: Integer, desc: "ID del vehículo eliminado"
      end
      route_param :id do
        get :restoration_viability do
          vehicle = Vehicle.discarded.find(params[:id])
          viability = vehicle.restoration_viability

          present({
            success: true,
            vehicle_id: vehicle.id,
            vehicle_info: {
              matricula: vehicle.matricula,
              company_name: vehicle.company.name,
              deleted_at: vehicle.discarded_at
            },
            viability: viability
          })
        end
      end

      desc "Obtener estado de eliminación de un vehículo"
      params do
        requires :id, type: Integer, desc: "ID del vehículo"
      end
      route_param :id do
        get :deletion_status do
          vehicle = Vehicle.with_discarded.find(params[:id])

          status_info = {
            vehicle_id: vehicle.id,
            matricula: vehicle.matricula,
            is_deleted: vehicle.discarded?,
            status_description: vehicle.deletion_status_description
          }

          if vehicle.discarded?
            # Información adicional para vehículos eliminados
            deletion_log = SoftDeleteAuditLog
              .deletions
              .for_record(vehicle)
              .order(performed_at: :desc)
              .first

            status_info.merge!(
              deleted_at: vehicle.discarded_at,
              can_be_restored: vehicle.can_be_restored?,
              deletion_log_id: deletion_log&.id,
              cascade_count: deletion_log&.cascade_count || 0,
              restore_complexity: deletion_log&.restore_complexity
            )
          else
            # Información adicional para vehículos activos
            status_info.merge!(
              total_km_records: vehicle.vehicle_kms.kept.count,
              total_maintenances: vehicle.maintenances.kept.count,
              conflictive_kms: vehicle.vehicle_kms.kept.conflictive.count
            )
          end

          present(status_info)
        end
      end
    end
  end
end
